"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const logger_1 = require("../logger/logger");
const error_1 = require("../error");
const core_1 = require("../core");
const injector_1 = require("../injector/injector");
const route_rule_1 = require("./route-rule");
const injectable_1 = require("../decorators/injectable");
const inject_1 = require("../decorators/inject");
/**
 * @since 1.0.0
 * @enum
 * @name Methods
 *
 * @description
 * Request methods
 */
(function (Methods) {
    Methods[Methods["GET"] = 0] = "GET";
    Methods[Methods["HEAD"] = 1] = "HEAD";
    Methods[Methods["DELETE"] = 2] = "DELETE";
    Methods[Methods["TRACE"] = 3] = "TRACE";
    Methods[Methods["OPTIONS"] = 4] = "OPTIONS";
    Methods[Methods["CONNECT"] = 5] = "CONNECT";
    Methods[Methods["POST"] = 6] = "POST";
    Methods[Methods["PUT"] = 7] = "PUT";
    Methods[Methods["PATCH"] = 8] = "PATCH";
})(exports.Methods || (exports.Methods = {}));
var Methods = exports.Methods;
/**
 * @since 1.0.0
 * @function
 * @name getMethod
 * @param {string} method
 *
 * @description
 * Get method enum from method string
 * @throws TypeError
 */
function getMethod(method) {
    if (method === "GET") {
        return Methods.GET;
    }
    else if (method === "HEAD") {
        return Methods.HEAD;
    }
    else if (method === "DELETE") {
        return Methods.DELETE;
    }
    else if (method === "TRACE") {
        return Methods.TRACE;
    }
    else if (method === "OPTIONS") {
        return Methods.OPTIONS;
    }
    else if (method === "CONNECT") {
        return Methods.CONNECT;
    }
    else if (method === "POST") {
        return Methods.POST;
    }
    else if (method === "PUT") {
        return Methods.PUT;
    }
    else if (method === "PATCH") {
        return Methods.PATCH;
    }
    throw new TypeError(`Method ${method} is not known method by standard!`);
}
exports.getMethod = getMethod;
/**
 * @since 1.0.0
 * @class
 * @name Router
 * @constructor
 * @description
 * Router is a component for handling routing in system.
 * All routes should be added during bootstrap process
 * @example
 * import { Bootstrap, Router } from "../core";
 * import { Assets } from "./components/assets";
 *
 * \@Bootstrap({
 *    port: 9000
 * })
 * export class Application {
 *   constructor(assets: Assets, router: Router) {
 *       router.add()
 *   }
 * }
 */
let Router_1;
let Router = Router_1 = class Router {
    constructor() {
        /**
         * Array of routes definition
         * @type {Array}
         */
        this.routes = [];
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#prefixSlash
     * @param {string} value
     * @static
     * @private
     *
     * @description
     * Prefixes url with starting slash
     */
    static prefixSlash(value) {
        return value.charAt(0) === "/" ? value : "/" + value;
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#addRules
     * @param {Array<RouteRuleConfig>} rules
     *
     * @description
     * Add route to routes list.
     * All routes must be inherited from Route interface.
     */
    addRules(rules) {
        this.logger.info("Router.addRules", rules);
        rules.forEach(config => this.routes.push(this.addRule(route_rule_1.RouteRule, config)));
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#addRule
     * @param {Function} Class
     * @param {RouteRuleConfig} config
     *
     * @description
     * Add rule to router
     */
    addRule(Class, config) {
        let injector = injector_1.Injector.createAndResolveChild(this.injector, Class, [
            { provide: "config", useValue: config }
        ]);
        return injector.get(Class);
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#parseRequest
     * @param {String} pathName
     * @param {String} method
     * @param {Headers} headers
     *
     * @description
     * Parse request based on pathName and method
     */
    parseRequest(pathName, method, headers) {
        return __awaiter(this, void 0, Promise, function* () {
            for (let route of this.routes) {
                let result = yield route.parseRequest(pathName, method, headers);
                if (core_1.isTruthy(result)) {
                    this.logger.info("Router.parseRequest", result);
                    return Promise.resolve(result);
                }
            }
            throw new error_1.HttpError(404, `Router.parseRequest: ${pathName} no route found, method: ${method}`, {
                pathName: pathName,
                method: method
            });
        });
    }
    /**
     * @since 1.0.0
     * @function
     * @name Router#createUrl
     * @param {String} routeName
     * @param {Object} params
     *
     * @description
     * Create url based on route and params
     */
    createUrl(routeName, params) {
        return __awaiter(this, void 0, Promise, function* () {
            for (let route of this.routes) {
                let result = yield route.createUrl(routeName, params);
                if (core_1.isTruthy(result)) {
                    this.logger.info("Router.createUrl", result);
                    return Promise.resolve(Router_1.prefixSlash(result));
                }
            }
            if (Object.keys(params).length > 0) {
                routeName += "?";
                Object.keys(params).forEach((k) => {
                    routeName += k + "=" + encodeURIComponent(params[k]);
                });
            }
            this.logger.info("Router.createUrl", Router_1.prefixSlash(routeName));
            return Promise.resolve(Router_1.prefixSlash(routeName));
        });
    }
};
__decorate([
    inject_1.Inject(logger_1.Logger), 
    __metadata('design:type', logger_1.Logger)
], Router.prototype, "logger", void 0);
__decorate([
    inject_1.Inject(injector_1.Injector), 
    __metadata('design:type', injector_1.Injector)
], Router.prototype, "injector", void 0);
Router = Router_1 = __decorate([
    injectable_1.Injectable(), 
    __metadata('design:paramtypes', [])
], Router);
exports.Router = Router;
//# sourceMappingURL=router.js.map