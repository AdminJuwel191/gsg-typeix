"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const router_1 = require("../router/router");
const core_1 = require("../core");
const logger_1 = require("../logger/logger");
const injector_1 = require("../injector/injector");
const events_1 = require("events");
const url_1 = require("url");
const error_1 = require("../error");
const inspect_1 = require("../logger/inspect");
const injectable_1 = require("../decorators/injectable");
const inject_1 = require("../decorators/inject");
const metadata_1 = require("../injector/metadata");
/**
 * Cookie parse regex
 * @type {RegExp}
 */
const COOKIE_PARSE_REGEX = /(\w+[^=]+)=([^;]+)/g;
/**
 * @since 1.0.0
 * @class
 * @name Request
 * @constructor
 * @description
 * Request is responsible for handling router result and processing all requests in system
 * This component is used internally by framework
 *
 * @private
 */
let Request = class Request {
    constructor() {
        /**
         * @param {string} id
         * @description
         * UUID identifier of request
         */
        this.id = core_1.uuid();
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#destroy
     * @private
     * @description
     * Destroy all references to free memory
     */
    destroy() {
        this.eventEmitter.emit("destroy");
        this.eventEmitter.removeAllListeners();
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#afterConstruct
     * @private
     * @description
     * This function is called by injector after constructor is initialized
     */
    afterConstruct() {
        this.url = url_1.parse(this.request.url, true);
        this.logger.trace("Request.args", {
            id: this.id,
            url: this.url
        });
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#render
     * @param {Buffer|String} response
     * @private
     * @description
     * This method sends data to client
     */
    render(response) {
        this.logger.info("Request.render", {
            id: this.id
        });
        if (core_1.isString(response) || (response instanceof Buffer)) {
            this.response.writeHead(this.statusCode, { "Content-Type": this.contentType });
            this.response.write(response);
            this.response.end();
            return response;
        }
        this.logger.error("Invalid response type", {
            id: this.id,
            response: response,
            type: typeof response
        });
        throw new error_1.HttpError(500, "ResponseType must be string or buffer", {
            response: response
        });
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#handleController
     * @private
     * @description
     * Handle controller instance
     */
    handleController(name, actionName, resolvedRoute) {
        return __awaiter(this, void 0, Promise, function* () {
            // find controller
            let controllerProvider = this.controllers
                .map(item => metadata_1.Metadata.verifyProvider(item))
                .find((Class) => {
                let metadata = metadata_1.Metadata.getComponentConfig(Class.provide);
                return metadata.name === name;
            });
            if (!core_1.isPresent(controllerProvider)) {
                throw new error_1.HttpError(500, `You must define controller within current route`, {
                    name: name,
                    actionName: actionName,
                    resolvedRoute: resolvedRoute
                });
            }
            // get controller metadata
            let metadata = metadata_1.Metadata.getComponentConfig(controllerProvider.provide);
            let providers = metadata_1.Metadata.verifyProviders(metadata.providers);
            let injector = new injector_1.Injector(this.injector);
            injector.createAndResolve(controllerProvider, providers);
            // create controller instance
            let instance = injector.get(controllerProvider.provide);
            let mappings = metadata_1.Metadata.getMetadata(instance, metadata_1.FUNCTION_KEYS);
            let mappedAction = mappings.find(item => item.type === "Action" && item.value === actionName);
            if (!core_1.isPresent(mappedAction)) {
                throw new error_1.HttpError(500, `Action is not defined on controller ${metadata_1.Metadata.getName(instance)}`, {
                    instance: instance,
                    name: name,
                    actionName: actionName,
                    resolvedRoute: resolvedRoute
                });
            }
            // get action
            let action = instance[mappedAction.key].bind(instance);
            // content type
            let contentType = mappings.find(item => item.type === "Produces" && item.key === mappedAction.key);
            if (core_1.isPresent(contentType)) {
                this.contentType = contentType;
            }
            // resolve action call
            return Promise.resolve(yield action()).then(resolved => this.render(resolved));
        });
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#handleModule
     * @private
     * @description
     * Handle module instance
     */
    handleModule(module, name, action, resolvedRoute) {
        throw new error_1.HttpError(500, `Modules are not implemented in current version :)`, {
            module: module,
            name: name,
            action: action,
            resolvedRoute: resolvedRoute
        });
    }
    /**
     * @since 1.0.0
     * @function
     * @name Request#process
     * @private
     * @description
     * Process request logic
     */
    process() {
        // destroy on end
        if (!this.isForwarded) {
            this.response.once("finish", () => this.destroy());
            // destroy if connection was terminated before end
            this.response.once("close", () => this.destroy());
        }
        // process request
        return this.router
            .parseRequest(this.url.pathname, this.request.method, this.request.headers)
            .then((resolvedRoute) => {
            this.logger.info("Route.parseRequest", {
                id: this.id,
                isCustomError: this.isCustomError,
                isForwarded: this.isForwarded,
                method: this.request.method,
                path: this.url.pathname,
                route: resolvedRoute
            });
            if ([router_1.Methods.POST, router_1.Methods.PATCH, router_1.Methods.PUT].indexOf(resolvedRoute.method) > -1 && !this.isForwarded) {
                this.request.on("data", item => this.data.push(item));
                return new Promise(resolve => this.request.on("end", resolve.bind({}, resolvedRoute)));
            }
            return resolvedRoute;
        })
            .then((resolvedRoute) => {
            let [module, controller, action] = resolvedRoute.route.split("/");
            if (!core_1.isPresent(action)) {
                return this.handleController(module, controller, resolvedRoute);
            }
            else if (core_1.isPresent(action)) {
                return this.handleModule(module, controller, action, resolvedRoute);
            }
            throw new error_1.HttpError(500, `Route definition is invalid, route must contain controller/action or module/controller/action pattern`, {
                resolvedRoute: resolvedRoute
            });
        })
            .catch((error) => {
            // force HttpError to be thrown
            if (!(error instanceof error_1.HttpError)) {
                let _error = error;
                error = new error_1.HttpError(500, _error.message, {});
                error.stack = _error.stack;
            }
            // log error message
            this.logger.error(error.message, {
                id: this.id,
                method: this.request.method,
                request: this.url,
                url: this.request.url,
                error: error
            });
            // status code is mutable
            this.statusCode = error.getCode();
            // render error
            return this.render(inspect_1.clean(error.toString()));
        })
            .catch((error) => {
            // set status code
            this.statusCode = error.getCode();
            // clean log output
            return this.render(inspect_1.clean(error.toString()));
        })
            .catch((error) => this.logger.error(error.message, {
            id: this.id,
            method: this.request.method,
            request: this.url,
            url: this.request.url,
            error: error
        }));
    }
};
__decorate([
    inject_1.Inject("request"), 
    __metadata('design:type', Object)
], Request.prototype, "request", void 0);
__decorate([
    inject_1.Inject("response"), 
    __metadata('design:type', Object)
], Request.prototype, "response", void 0);
__decorate([
    inject_1.Inject("isCustomError"), 
    __metadata('design:type', Boolean)
], Request.prototype, "isCustomError", void 0);
__decorate([
    inject_1.Inject("isForwarded"), 
    __metadata('design:type', Boolean)
], Request.prototype, "isForwarded", void 0);
__decorate([
    inject_1.Inject("isForwarder"), 
    __metadata('design:type', Boolean)
], Request.prototype, "isForwarder", void 0);
__decorate([
    inject_1.Inject("data"), 
    __metadata('design:type', Array)
], Request.prototype, "data", void 0);
__decorate([
    inject_1.Inject("modules"), 
    __metadata('design:type', Array)
], Request.prototype, "modules", void 0);
__decorate([
    inject_1.Inject("controllers"), 
    __metadata('design:type', Array)
], Request.prototype, "controllers", void 0);
__decorate([
    inject_1.Inject("statusCode", true), 
    __metadata('design:type', Number)
], Request.prototype, "statusCode", void 0);
__decorate([
    inject_1.Inject(injector_1.Injector), 
    __metadata('design:type', injector_1.Injector)
], Request.prototype, "injector", void 0);
__decorate([
    inject_1.Inject(logger_1.Logger), 
    __metadata('design:type', logger_1.Logger)
], Request.prototype, "logger", void 0);
__decorate([
    inject_1.Inject(router_1.Router), 
    __metadata('design:type', router_1.Router)
], Request.prototype, "router", void 0);
__decorate([
    inject_1.Inject(events_1.EventEmitter), 
    __metadata('design:type', events_1.EventEmitter)
], Request.prototype, "eventEmitter", void 0);
__decorate([
    inject_1.Inject("contentType", true), 
    __metadata('design:type', String)
], Request.prototype, "contentType", void 0);
Request = __decorate([
    injectable_1.Injectable(), 
    __metadata('design:paramtypes', [])
], Request);
exports.Request = Request;
//# sourceMappingURL=request.js.map